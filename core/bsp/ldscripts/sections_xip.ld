/**
 ****************************************************************************************
 *
 * @file sections_xip.ld
 *
 * @brief linker script for DA16200 RTOS
 *
 * Copyright (c) 2016-2019 Dialog Semiconductor. All rights reserved.
 * 
 * This software ("Software") is owned by Dialog Semiconductor.
 * 
 * By using this Software you agree that Dialog Semiconductor retains all
 * intellectual property and proprietary rights in and to this Software and any
 * use, reproduction, disclosure or distribution of the Software without express
 * written permission or a license agreement from Dialog Semiconductor is
 * strictly prohibited. This Software is solely for use on or in conjunction
 * with Dialog Semiconductor products.
 * 
 * EXCEPT AS OTHERWISE PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, THE
 * SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT. EXCEPT AS OTHERWISE
 * PROVIDED IN A LICENSE AGREEMENT BETWEEN THE PARTIES, IN NO EVENT SHALL
 * DIALOG SEMICONDUCTOR BE LIABLE FOR ANY DIRECT, SPECIAL, INDIRECT, INCIDENTAL,
 * OR CONSEQUENTIAL DAMAGES, OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF
 * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR OTHER
 * TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
 * OF THE SOFTWARE.
 * 
 ****************************************************************************************
 */


/*
 * The '__Main_Stack_Limit' definition is required by startup_ARMCM4.S,
 * do not remove it.
 */
 /*
 * The '_Heap_Begin' & '_Heap_Limit' definitions are required by _sbrk.c,
 * do not remove it.
 */

INCLUDE mem.ld

/*
 * Default stack sizes.
 * These are used by the startup in order to allocate stacks 
 * for the different modes.
 */

__Main_Stack_Size = LENGTH(CSTACK) ;

PROVIDE ( _Main_Stack_Size = __Main_Stack_Size ) ;

__Main_Stack_Limit = __stack + __Main_Stack_Size ;

/* "PROVIDE" allows to easily override these values from an 
 * object file or the command line. */
PROVIDE ( _Main_Stack_Limit = __Main_Stack_Limit ) ;

/*
 * There will be a link error if there is not this amount of 
 * RAM free at the end. 
 */
_Minimum_RAM_Margin = 16 ;

/*
 * Default heap definitions.
 * The heap start immediately after the last statically allocated 
 * .sbss/.noinit section, and extends up to the end of ram.
 */
PROVIDE ( _Heap_Begin = _end_noinit ) ;
PROVIDE ( _Heap_Limit = __SRAM_segment_end__ - _Minimum_RAM_Margin ) ;

/* 
 * The entry point is informative, for debuggers and simulators,
 * since the Cortex-M vector points to it anyway.
 */
ENTRY(_start)


/* Sections Definitions */

SECTIONS
{
	/*
	 * For Cortex-M devices, the beginning of the startup code is stored in
	 * the .isr_vector section. 
	 */

	.isr_vector (ORIGIN(CACHE)+0x1400) : 
	{
		__region_ROM_start__ = ABSOLUTE(.);
		__vectors_start = ABSOLUTE(.) ;
		__vectors_start__ = ABSOLUTE(.) ;
		KEEP(*(.isr_vector))				/* Interrupt vectors */

		/* 
		 * This section is here for convenience, to store the
		 * startup code at the beginning of the flash area, hoping that
		 * this will increase the readability of the listing.
		 */
		. = ALIGN(4);
		*(.after_vectors .after_vectors.*)	/* Startup code and ISR */
	
		. = ALIGN(4);
		*(.text .text.*)			/* all remaining code */
 
 		/* read-only data (constants) */
		*(.rodata .rodata.* .constdata .constdata.*) 		

		*(vtable)					/* C++ virtual tables */

		KEEP(*(.eh_frame*))

		/*
		 * Stub sections generated by the linker, to glue together 
		 * ARM and Thumb code. .glue_7 is used for ARM code calling 
		 * Thumb code, and .glue_7t is used for Thumb code calling 
		 * ARM code. Apparently always generated by the linker, for some
		 * architectures, so better leave them here.
		 */
		*(.glue_7)
		*(.glue_7t)

	} >CACHE AT > FLASH 	

	.inits : 
	{
		__data_regions_array_start = . ;

		LONG(ADDR(.isr_vector)+LOADADDR(.ram_text));
		LONG(ADDR(.ram_text));
		LONG(ADDR(.ram_text)+SIZEOF(.ram_text));

		LONG(ADDR(.isr_vector)+LOADADDR(.data));
		LONG(ADDR(.data));
		LONG(ADDR(.data)+SIZEOF(.data));

		__data_regions_array_end = . ;
		
		. = ALIGN(4);
		
		__bss_regions_array_start = . ;
		
		LONG(ADDR(.bss));
		LONG(ADDR(.bss)+SIZEOF(.bss));

		__bss_regions_array_end = . ;  
		

		. = ALIGN(4);
		KEEP(*(.init))
		KEEP(*(.fini))

	} >CACHE AT > FLASH

	.ram_text : 
	{
		. = ALIGN(4);
		*(.ram_text .ram_text.*)

		. = ALIGN(4);
		*(.ram_rodata .ram_rodata.*)
	} >RAM1 AT > FLASH

	/* 
	 * This address is used by the startup code to 
	 * initialise the .data section.
	 */

	.data : 
	{
		. = ALIGN(4);
		*(.data_begin .data_begin.*)
		*(.data .data.*)
		*(.data_end .data_end.*)

	} >RAM1 AT > FLASH

	/*
	 * The uninitialised data sections. NOLOAD is used to avoid
	 * the "section `.bss' type changed to PROGBITS" warning
	 */

	/* The primary uninitialised data section. */
	.bss (NOLOAD) : ALIGN(4)
	{
		*(.bss_begin .bss_begin.*)
		*(.bss .bss.*)
		*(COMMON)
		*(.bss_end .bss_end.*)
	} >RAM1

	.noinit (NOLOAD) : ALIGN(4)
	{
		*(.noinit .noinit.*) 

		. = ALIGN(4) ;
		_end_noinit = .;
	} >RAM1

	.ipd (NOLOAD) :
	{
		__region_RAMIPD_start__ = .;
		*(.ipd .ipd.*)
	} >RAMIPD

	.ARM.exidx :
	{
		__exidx_start = .;
		*(.ARM.exidx* .gnu.linkonce.armexidx.*)
		__exidx_end = .;
	} >RAM1 AT > FLASH
	_etext = .;            /* define a global symbol _etext just after the last code byte */

	/* Here is the heap space. Do not assign any sections ! */
	
	/*
	 * Used for validation only, do not allocate anything here!
	 *
	* This is just to check that there is enough RAM.
	* It should generate an error if it's full.
	 */
	._check_ram (NOLOAD) : ALIGN(4)
	{
		. = . + _Minimum_RAM_Margin ;
	} >RAM1

	/* After that there are only debugging sections. */

	/* This can remove the debugging information from the standard libraries */
	/* 
	DISCARD :
	{
		libc.a ( * )
		libm.a ( * )
		libgcc.a ( * )
	}
	*/

	/* Stabs debugging sections. */
	.stab			0 : { *(.stab) }
	.stabstr		0 : { *(.stabstr) }
	.stab.excl		0 : { *(.stab.excl) }
	.stab.exclstr	0 : { *(.stab.exclstr) }
	.stab.index		0 : { *(.stab.index) }
	.stab.indexstr	0 : { *(.stab.indexstr) }
	.comment		0 : { *(.comment) }
	/*
	 * DWARF debug sections.
	 * Symbols in the DWARF debugging sections are relative to the beginning
	 * of the section so we begin them at 0.
	 */
	/* DWARF 1 */
	.debug			0 : { *(.debug) }
	.line			0 : { *(.line) }
	/* GNU DWARF 1 extensions */
	.debug_srcinfo	0 : { *(.debug_srcinfo) }
	.debug_sfnames	0 : { *(.debug_sfnames) }
	/* DWARF 1.1 and DWARF 2 */
	.debug_aranges	0 : { *(.debug_aranges) }
	.debug_pubnames 0 : { *(.debug_pubnames) }
	/* DWARF 2 */
	.debug_info		0 : { *(.debug_info .gnu.linkonce.wi.*) }
	.debug_abbrev	0 : { *(.debug_abbrev) }
	.debug_line		0 : { *(.debug_line) }
	.debug_frame	0 : { *(.debug_frame) }
	.debug_str		0 : { *(.debug_str) }
	.debug_loc		0 : { *(.debug_loc) }
	.debug_macinfo	0 : { *(.debug_macinfo) }
	/* SGI/MIPS DWARF 2 extensions */
	.debug_weaknames 0 : { *(.debug_weaknames) }
	.debug_funcnames 0 : { *(.debug_funcnames) }
	.debug_typenames 0 : { *(.debug_typenames) }
	.debug_varnames	0 : { *(.debug_varnames) }
}
